## 1. Базовый Концепт и Архитектура

### Что такое UUID?
**UUID (Universally Unique Identifier)** — это 128-битное число, используемое для уникальной идентификации информации. Благодаря крайне малой вероятности коллизий, UUID идеально подходит для идентификации счетов и транзакций в **распределенных и асинхронных** системах, исключая необходимость в центральном органе регистрации ID.

---

### Оценка Архитектуры и Улучшения
Предложенная архитектура является **рабочей** и хорошо структурирована.

| Улучшение | Класс | Причина                                                                                                                                               |
| :--- | :--- |:------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Статус транзакции** | `model.TransactionRequest` | Поле `status` (`PENDING`, `COMPLETED`, `REJECTED`) стоит добавить для **мониторинга** и отслеживания жизненного цикла операции в асинхронной очереди. |
| **Сервисный слой** | `service.AsyncTransactionProcessor` | Логика обработки и изменения балансов вынесена в отдельный слой **`service`**, что соответствует принципам **SOLID** и обеспечивает чистоту кода.     |

---

## 2. Принципы SOLID

Применение принципов SOLID непосредственно связано с транзакционной логикой:

| Принцип | Реализация в проекте | Классы |
| :--- | :--- | :--- |
| **S** (Single Responsibility) | Классы DAO отвечают **только** за взаимодействие с БД. | `dao.AccountDAO` |
| **O** (Open/Closed) | Паттерн **Стратегия**. Для добавления новой операции (например, "Оплата счетов") достаточно создать новый класс, не меняя основной обработчик **`AsyncTransactionProcessor`**. | `strategy.TransactionStrategy` |
| **L** (Liskov Substitution) | `AsyncTransactionProcessor` работает с переменной типа **`TransactionStrategy`**, принимая любую реализацию (`DepositStrategy`, `FreezeStrategy` и т.д.) без изменения своего поведения. | `strategy.TransactionStrategy` |
| **I** (Interface Segregation) | (В проекте **не применен** ввиду отсутствия больших интерфейсов). | |
| **D** (Dependency Inversion) | Классы высокого уровня (`service`) получают реализации DAO (`dao`) через **конструктор**, а не создают их сами (Dependency Injection). | `dao.AccountDAO` |

---

## 3. Паттерны Проектирования

| Паттерн | Применение | Класс/Пакет |
| :--- | :--- | :--- |
| **Стратегия (Strategy)** | Инкапсуляция логики каждой операции (`DEPOSIT`, `WITHDRAW`, `FREEZE`) в отдельный класс-стратегию. | `strategy.*Strategy` |
| **Команда (Command)** | **`TransactionRequest`** инкапсулирует запрос на выполнение, позволяя помещать его в очередь для асинхронной обработки. | `model.TransactionRequest` |
| **Одиночка (Singleton)** | Класс **`DatabaseManager`** реализован как Singleton для обеспечения единой и контролируемой точки доступа к соединению JDBC. | `db.DatabaseManager` |
| **Фабрика (Factory)** | Используется для создания конкретной стратегии (`TransactionStrategy`) на основе типа операции (`ActionType`). | `factory.TransactionFactory` |
| **Наблюдатель (Observer)** | Класс **`AsyncTransactionProcessor`** (Субъект) уведомляет UI-компоненты (Наблюдатели) после выполнения транзакции для обновления логов и интерфейса. | `service.AsyncTransactionProcessor` (с UI-компонентом в пакете `visitor`) |
---

## 4. Асинхронность и Атомарность

### Механизмы Java для Атомарности
Для безопасной работы в многопоточной среде используются:
* **Транзакции JDBC:** При работе с СУБД (через `dao.AccountDAO`) используется явное управление транзакциями (`conn.setAutoCommit(false)`), гарантирующее **атомарность** (ACID) на уровне базы данных.
* **Потокобезопасные структуры:** **`BlockingQueue`** используется для очереди запросов, обеспечивая безопасную передачу команд между потоками.

### Асинхронный Обработчик
Реализован паттерн **Producer-Consumer** в классе **`AsyncTransactionProcessor`**:
1.  **Producer (UI/API):** Создает `TransactionRequest` и помещает его в `BlockingQueue`.
2.  **Consumer (Рабочий поток):** **`AsyncTransactionProcessor`** запускает поток, который **последовательно** извлекает запросы и передает их на выполнение.

**Атомарность:** Обработка запросов происходит в строгой последовательности, а изменения баланса осуществляются внутри **единой транзакции СУБД**, что исключает гонки данных и гарантирует консистентность.

---

## Настройка Запуска (Для IntelliJ IDEA)

Ввиду нестандартной структуры проекта с несколькими лабами, для запуска необходимо:

1.  **Синхронизировать Maven:** Открыть панель **Maven** и нажать **Reload All Maven Projects**.
2.  **Настройка запуска:** Открыть **Edit Configurations**.
3.  **Указать модуль:** В поле **"Use classpath of module"** выбрать имя модуля.
4.  **Сборка:** Запустить `Main` после выполнения **Build → Rebuild Project**.